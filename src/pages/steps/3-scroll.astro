---
import Layout from '@/layouts/Layout.astro'
---

<Layout>
  <div class="image-stack">
    <img src="/01.webp" class="image-item" alt="image" />
    <img src="/02.webp" class="image-item" alt="image" />
    <img src="/03.webp" class="image-item" alt="image" />
    <img src="/04.webp" class="image-item" alt="image" />
    <img src="/05.webp" class="image-item" alt="image" />
    <img src="/06.webp" class="image-item" alt="image" />
    <img src="/07.webp" class="image-item" alt="image" />
    <img src="/08.webp" class="image-item" alt="image" />
    <img src="/09.webp" class="image-item" alt="image" />
    <img src="/10.webp" class="image-item" alt="image" />
    <img src="/11.webp" class="image-item" alt="image" />
    <img src="/12.webp" class="image-item" alt="image" />
    <img src="/13.webp" class="image-item" alt="image" />
    <img src="/14.webp" class="image-item" alt="image" />
    <img src="/15.webp" class="image-item" alt="image" />
    <img src="/16.webp" class="image-item" alt="image" />
    <img src="/17.webp" class="image-item" alt="image" />
    <img src="/18.webp" class="image-item" alt="image" />
    <img src="/19.webp" class="image-item" alt="image" />
    <img src="/20.webp" class="image-item" alt="image" />
    <img src="/21.webp" class="image-item" alt="image" />
    <img src="/22.webp" class="image-item" alt="image" />
    <img src="/23.webp" class="image-item" alt="image" />
    <img src="/24.webp" class="image-item" alt="image" />
    <img src="/25.webp" class="image-item" alt="image" />
    <img src="/26.webp" class="image-item" alt="image" />
    <img src="/27.webp" class="image-item" alt="image" />
    <img src="/28.webp" class="image-item" alt="image" />
    <img src="/29.webp" class="image-item" alt="image" />
    <img src="/30.webp" class="image-item" alt="image" />
    <img src="/31.webp" class="image-item" alt="image" />
    <img src="/32.webp" class="image-item" alt="image" />
    <img src="/33.webp" class="image-item" alt="image" />
    <img src="/34.webp" class="image-item" alt="image" />
    <img src="/35.webp" class="image-item" alt="image" />
    <img src="/36.webp" class="image-item" alt="image" />
    <img src="/37.webp" class="image-item" alt="image" />
    <img src="/38.webp" class="image-item" alt="image" />
    <img src="/39.webp" class="image-item" alt="image" />
    <img src="/40.webp" class="image-item" alt="image" />
    <img src="/41.webp" class="image-item" alt="image" />
    <img src="/42.webp" class="image-item" alt="image" />
    <img src="/43.webp" class="image-item" alt="image" />
    <img src="/44.webp" class="image-item" alt="image" />
    <img src="/45.webp" class="image-item" alt="image" />
    <img src="/46.webp" class="image-item" alt="image" />
    <img src="/47.webp" class="image-item" alt="image" />
    <img src="/48.webp" class="image-item" alt="image" />
    <img src="/49.webp" class="image-item" alt="image" />
    <img src="/50.webp" class="image-item" alt="image" />
    <img src="/51.webp" class="image-item" alt="image" />
    <img src="/52.webp" class="image-item" alt="image" />
    <img src="/53.webp" class="image-item" alt="image" />
    <img src="/54.webp" class="image-item" alt="image" />
    <img src="/55.webp" class="image-item" alt="image" />
    <img src="/56.webp" class="image-item" alt="image" />
    <img src="/57.webp" class="image-item" alt="image" />
    <img src="/58.webp" class="image-item" alt="image" />
    <img src="/59.webp" class="image-item" alt="image" />
    <img src="/60.webp" class="image-item" alt="image" />
    <img src="/61.webp" class="image-item" alt="image" />
    <img src="/62.webp" class="image-item" alt="image" />
    <img src="/63.webp" class="image-item" alt="image" />
    <img src="/64.webp" class="image-item" alt="image" />
    <img src="/65.webp" class="image-item" alt="image" />
    <img src="/66.webp" class="image-item" alt="image" />
    <img src="/67.webp" class="image-item" alt="image" />
    <img src="/68.webp" class="image-item" alt="image" />
    <img src="/69.webp" class="image-item" alt="image" />
    <img src="/70.webp" class="image-item" alt="image" />
    <img src="/71.webp" class="image-item" alt="image" />
    <img src="/72.webp" class="image-item" alt="image" />
    <img src="/73.webp" class="image-item" alt="image" />
    <img src="/74.webp" class="image-item" alt="image" />
    <img src="/75.webp" class="image-item" alt="image" />
    <img src="/76.webp" class="image-item" alt="image" />
    <img src="/77.webp" class="image-item" alt="image" />
    <img src="/78.webp" class="image-item" alt="image" />
    <img src="/79.webp" class="image-item" alt="image" />
    <img src="/80.webp" class="image-item" alt="image" />
    <img src="/81.webp" class="image-item" alt="image" />
    <img src="/82.webp" class="image-item" alt="image" />
    <img src="/83.webp" class="image-item" alt="image" />
    <img src="/84.webp" class="image-item" alt="image" />
    <img src="/85.webp" class="image-item" alt="image" />
    <img src="/86.webp" class="image-item" alt="image" />
    <img src="/87.webp" class="image-item" alt="image" />
    <img src="/88.webp" class="image-item" alt="image" />
    <img src="/89.webp" class="image-item" alt="image" />
    <img src="/90.webp" class="image-item" alt="image" />
    <img src="/91.webp" class="image-item" alt="image" />
    <img src="/92.webp" class="image-item" alt="image" />
    <img src="/93.webp" class="image-item" alt="image" />
    <img src="/94.webp" class="image-item" alt="image" />
    <img src="/95.webp" class="image-item" alt="image" />
    <img src="/96.webp" class="image-item" alt="image" />
    <img src="/97.webp" class="image-item" alt="image" />
    <img src="/98.webp" class="image-item" alt="image" />
    <img src="/99.webp" class="image-item" alt="image" />
    <img src="/100.webp" class="image-item" alt="image" />
  </div>
</Layout>

<style>
html,
body {
  overflow: hidden;
}

.image-stack {
  --animation-duration: 0.8s;
  --animation-easing: cubic-bezier(0.645, 0.045, 0.355, 1);

  /* Center child image */
  display: flex;
  align-items: center;
  justify-content: center;

  /* Full screen */
  width: 100dvw;
  height: 100dvh;

  /* Optimize performance and prevent mobile scroll */
  contain: content;
}

.image-stack.loaded {
  --animation-duration: 0.6s;
}

.image-stack.scrolling {
  --animation-easing: cubic-bezier(0.215, 0.61, 0.355, 1);
}

.image-item {
  /* Overlap all images */
  position: absolute;

  /* Max Size Limit */
  max-width: var(--image-size);
  max-height: var(--image-size);

  /* 3D perspective effect and scale */
  transform: translate3d(var(--offset-x, 0px), var(--offset-y, 0px), 0px) perspective(none) rotateX(-45deg) rotateY(-45deg) scale(var(--image-scale));
  transition: transform var(--animation-duration) var(--animation-easing);

  /* Optimize performance */
  backface-visibility: hidden;
  will-change: transform;
}

.image-stack.loaded .image-item.zoomed {
  transform: translate3d(var(--offset-x, 0px), var(--offset-y, 0px), 0px) perspective(800px) rotateX(0deg) rotateY(0deg) scale(1);
}
</style>

<script>
const stackSlope = -0.6
const loadDuration = 1000
const switchModeDuration = 800
const switchImageCooldown = 400
const scrollDamping = 0.92
const scrollThreshold = 50

let resizeTimer: number
let scrollTimer: number | null = null
let cachedImageStack: HTMLElement | null = null
let cachedImages: HTMLImageElement[] | null = null
let currentCenterIndex: number | null = null
let cachedLayoutConfig: { width: number, height: number, result: ReturnType<typeof getLayoutConfig> } | null = null
let cachedSpacingFactor: { width: number, result: number } | null = null
let stackScrollOffset = 0
let scrollAccumulator = 0
let lastSwitchTime = 0
let isWheeling = false

function cleanup(): void {
  clearTimeout(resizeTimer)
  if (scrollTimer) {
    clearTimeout(scrollTimer)
  }

  cachedImageStack = null
  cachedImages = null
  currentCenterIndex = null
  cachedLayoutConfig = null
  cachedSpacingFactor = null
  stackScrollOffset = 0
  scrollAccumulator = 0
  lastSwitchTime = 0
  isWheeling = false
}

// ==========================================================================================================================================================
// RESPONSIVE CALCULATION FUNCTIONS
// ==========================================================================================================================================================

/**
 * Responsive image size
 * <= 480px: 100dvw
 * 480px - 1600px: Linear scale from 480px to 800px
 * >= 1600px: 800px
 * Never exceeds 80dvh
 */
function getImageSize(width: number, height: number): number {
  const size = width <= 480
    ? width
    : width >= 1600
      ? 800
      : 480 + (width - 480) * 320 / 1120

  return Math.min(size, height * 0.8)
}

/**
 * Responsive image scale
 * <= 480px: 0.5
 * 480px - 1600px: Linear scale from 0.5 to 0.33
 * >= 1600px: 0.33
 */
function getImageScale(width: number): number {
  return Math.max(0.33, Math.min(0.5, 0.5 - (width - 480) * 0.17 / 1120))
}

/**
 * Calculate stack spacing
 * 480px: 63px spacing (when image is 480px × 0.5 = 240px wide)
 * 1600px: 70px spacing (when image is 800px × 0.33 = 264px wide)
 */
function getStackSpacing(size: number, scale: number): number {
  return size * scale * 63 / 240
}

function getLayoutConfig(): { size: number, scale: number, spacing: number } {
  const width = window.innerWidth
  const height = window.innerHeight
  const size = getImageSize(width, height)
  const scale = getImageScale(width)
  const spacing = getStackSpacing(size, scale)

  return { size, scale, spacing }
}

function getCachedLayoutConfig(): { size: number, scale: number, spacing: number } {
  const width = window.innerWidth
  const height = window.innerHeight

  // Use cached config for same viewport size
  if (cachedLayoutConfig
    && cachedLayoutConfig.width === width
    && cachedLayoutConfig.height === height) {
    return cachedLayoutConfig.result
  }

  const result = getLayoutConfig()
  cachedLayoutConfig = { width, height, result }

  return result
}

/**
 * Responsive expanded offset scale
 * <= 480px: 4.5
 * 480px - 1600px: Linear scale from 4.5 to 7
 * >= 1600px: 7
 */
function getExpandedSpacingFactor(): number {
  const viewportWidth = window.innerWidth
  const ratio = (viewportWidth - 480) / (1600 - 480)

  return viewportWidth >= 1600
    ? 7
    : viewportWidth <= 480
      ? 4.5
      : 4.5 + (7 - 4.5) * ratio
}

function getCachedExpandedSpacingFactor(): number {
  const width = window.innerWidth

  // Use cached spacing factor for same viewport width
  if (cachedSpacingFactor && cachedSpacingFactor.width === width) {
    return cachedSpacingFactor.result
  }

  const result = getExpandedSpacingFactor()
  cachedSpacingFactor = { width, result }

  return result
}

// ==========================================================================================================================================================
// STACK LAYOUT FUNCTIONS
// ==========================================================================================================================================================

function applyImageSizeAndScale(imageStack: HTMLElement, size: number, scale: number): void {
  const styles = {
    '--image-size': `${size}px`,
    '--image-scale': scale.toString(),
  }

  // Apply size and scale
  Object.entries(styles).forEach(([property, value]) => {
    imageStack.style.setProperty(property, value)
  })
}

function applyImageOffsets(
  images: HTMLImageElement[],
  centerIndex: number,
  spacing: number,
): void {
  const isZoomed = images[centerIndex].classList.contains('zoomed')

  // Base spacing calculations
  const baseSpacingX = spacing
  const baseSpacingY = spacing * stackSlope

  // Scroll offset calculations
  const stackScrollOffsetX = stackScrollOffset
  const stackScrollOffsetY = stackScrollOffset * stackSlope

  let expandedOffsetX = 0
  let expandedOffsetY = 0

  // Calculate expanded offsets (if zoomed)
  if (isZoomed) {
    const expandedOffset = spacing * getCachedExpandedSpacingFactor()
    expandedOffsetX = expandedOffset
    expandedOffsetY = expandedOffset * stackSlope
  }

  images.forEach((image, index) => {
    // Calculate base position
    const relativeIndex = centerIndex - index

    let offsetX = stackScrollOffsetX + baseSpacingX * relativeIndex
    let offsetY = stackScrollOffsetY + baseSpacingY * relativeIndex

    // Apply expanded offsets for non-center images when zoomed
    if (isZoomed) {
      if (index < centerIndex) {
        // Right group: move toward top-right
        offsetX += expandedOffsetX
        offsetY += expandedOffsetY
      }
      else if (index > centerIndex) {
        // Left group: move toward bottom-left
        offsetX -= expandedOffsetX
        offsetY -= expandedOffsetY
      }
    }

    const styles = {
      '--offset-x': `${offsetX}px`,
      '--offset-y': `${offsetY}px`,
    }

    // Apply styles
    Object.entries(styles).forEach(([property, value]) => {
      image.style.setProperty(property, value)
    })
  })
}

function setupStackLayout(): void {
  const imageStack = cachedImageStack ??= document.querySelector('.image-stack')
  if (!imageStack) {
    return
  }

  const images = cachedImages ??= Array.from(document.querySelectorAll('.image-item'))
  if (images.length === 0) {
    return
  }

  const defaultCenterIndex = Math.floor(images.length / 2)
  const { size, scale, spacing } = getCachedLayoutConfig()
  currentCenterIndex = defaultCenterIndex

  applyImageSizeAndScale(imageStack, size, scale)

  // Apply offsets after loading animation
  setTimeout(() => {
    if (currentCenterIndex === null) {
      return
    }

    applyImageOffsets(images, currentCenterIndex, spacing)
  }, loadDuration)

  // Add loaded class to allow interaction
  setTimeout(() => {
    imageStack.classList.add('loaded')
  }, loadDuration + switchModeDuration)
}

// ==========================================================================================================================================================
// UTILITY FUNCTIONS
// ==========================================================================================================================================================

function getStackDate(): {
  imageStack: HTMLElement
  images: HTMLImageElement[]
  currentCenterIndex: number
} | null {
  const imageStack = cachedImageStack ??= document.querySelector('.image-stack')
  if (!imageStack || !imageStack.classList.contains('loaded')) {
    return null
  }

  const images = cachedImages ??= Array.from(document.querySelectorAll('.image-item'))
  if (images.length === 0) {
    return null
  }

  // Check if valid center index
  if (currentCenterIndex === null
    || currentCenterIndex < 0
    || currentCenterIndex >= images.length) {
    return null
  }

  return { imageStack, images, currentCenterIndex }
}

function flashScrollingState(imageStack: HTMLElement): void {
  imageStack.classList.add('scrolling')

  // Clear existing timer
  if (scrollTimer) {
    clearTimeout(scrollTimer)
  }

  // Set new timer
  scrollTimer = window.setTimeout(() => {
    imageStack.classList.remove('scrolling')
    scrollTimer = null
  }, switchImageCooldown)
}

function switchToNextImage(
  imageStack: HTMLElement,
  images: HTMLImageElement[],
  currentIndex: number,
  nextIndex: number,
  shouldZoom: boolean,
): void {
  const { spacing } = getCachedLayoutConfig()

  // Remove zoomed class from current index
  images[currentIndex].classList.remove('zoomed')

  stackScrollOffset = 0
  currentCenterIndex = nextIndex

  // If the current center index is zoomed or the next index is not zoomed, shouldZoom is true
  if (shouldZoom) {
    imageStack.classList.remove('scrolling')
    images[nextIndex].classList.add('zoomed')
  }

  applyImageOffsets(images, nextIndex, spacing)
}

// ==========================================================================================================================================================
// EVENT HANDLER FUNCTIONS
// ==========================================================================================================================================================

/**
 * Resize Events
 * Handle resize events with responsive calculation
 */
function handleResize(): void {
  clearTimeout(resizeTimer)
  resizeTimer = window.setTimeout(() => {
    const stackDate = getStackDate()
    if (!stackDate) {
      return
    }

    const { imageStack, images, currentCenterIndex } = stackDate
    const { size, scale, spacing } = getCachedLayoutConfig()
    applyImageSizeAndScale(imageStack, size, scale)

    // Prevent rapid calculation from applyImageOffsets
    requestAnimationFrame(() => {
      applyImageOffsets(images, currentCenterIndex, spacing)
    })
  }, 100)
}

/**
 * Keydown Events
 * Handle keydown events for arrow and space keys
 */
function handleArrowKeys(
  event: KeyboardEvent,
  imageStack: HTMLElement,
  images: HTMLImageElement[],
  currentIndex: number,
  isZoomed: boolean,
  currentTime: number,
): void {
  // Add switch cooldown if zoomed
  if (isZoomed && (currentTime - lastSwitchTime < switchImageCooldown)) {
    return
  }

  // Add scrolling state if not zoomed
  if (!isZoomed) {
    flashScrollingState(imageStack)
  }

  const nextIndex = event.key === 'ArrowLeft'
    ? Math.min(currentIndex + 1, images.length - 1)
    : Math.max(currentIndex - 1, 0)

  // Prevent switching at boundary
  if (nextIndex === currentIndex) {
    return
  }

  event.preventDefault()
  switchToNextImage(imageStack, images, currentIndex, nextIndex, isZoomed)
  lastSwitchTime = currentTime
}

function handleSpaceKey(
  event: KeyboardEvent,
  imageStack: HTMLElement,
  images: HTMLImageElement[],
  currentIndex: number,
): void {
  event.preventDefault()
  const { spacing } = getCachedLayoutConfig()

  // If the stack has a scroll offset, toggle the nearest center index
  if (stackScrollOffset !== 0) {
    const nextIndex = Math.max(0, Math.min(currentIndex + Math.round(stackScrollOffset / spacing), images.length - 1))

    images[currentIndex].classList.remove('zoomed')

    stackScrollOffset = 0
    currentCenterIndex = nextIndex

    imageStack.classList.remove('scrolling')
    images[nextIndex].classList.toggle('zoomed')

    applyImageOffsets(images, nextIndex, spacing)
    return
  }

  // If the stack has no scroll offset, toggle the current index
  images[currentIndex].classList.toggle('zoomed')
  applyImageOffsets(images, currentIndex, spacing)
}

function handleKeyDown(event: KeyboardEvent): void {
  const stackDate = getStackDate()
  if (!stackDate) {
    return
  }

  const { imageStack, images, currentCenterIndex } = stackDate
  const isZoomed = images[currentCenterIndex].classList.contains('zoomed')
  const currentTime = Date.now()

  // Separate handling based on key type
  switch (event.key) {
    case 'ArrowLeft':
    case 'ArrowRight':
      handleArrowKeys(event, imageStack, images, currentCenterIndex, isZoomed, currentTime)
      break
    case ' ': {
      handleSpaceKey(event, imageStack, images, currentCenterIndex)
      break
    }
  }
}

/**
 * Click Events
 * Handle click events for zoomed and normal states
 */
function handleClick(event: MouseEvent): void {
  const stackDate = getStackDate()
  if (!stackDate) {
    return
  }

  const { imageStack, images, currentCenterIndex } = stackDate
  const target = event.target as HTMLElement
  const clickedImage = target.closest('.image-item') as HTMLImageElement

  // Image: click to zoom / collapse
  if (clickedImage) {
    // Prevent rapid clicking
    const currentTime = Date.now()
    if (currentTime - lastSwitchTime < switchImageCooldown) {
      return
    }

    const clickedIndex = images.indexOf(clickedImage)
    const isZoomed = clickedImage.classList.contains('zoomed')
    const shouldZoom = !isZoomed

    switchToNextImage(imageStack, images, currentCenterIndex, clickedIndex, shouldZoom)
    lastSwitchTime = currentTime
    return
  }

  // Empty space: collapse all images
  if (target.closest('.image-stack')) {
    const { spacing } = getCachedLayoutConfig()
    images[currentCenterIndex].classList.remove('zoomed')
    applyImageOffsets(images, currentCenterIndex, spacing)
  }
}

/**
 * Wheel Events
 * Handle wheel events for zoomed and normal states
 */
function handleWheelOnZoomed(
  event: WheelEvent,
  imageStack: HTMLElement,
  images: HTMLImageElement[],
  currentIndex: number,
  isZoomed: boolean,
): void {
  // Prevent rapid scrolling
  const currentTime = Date.now()
  if (currentTime - lastSwitchTime < switchImageCooldown) {
    return
  }

  // Accumulate scroll distance
  const delta = event.deltaY
  scrollAccumulator += delta

  // Ignore small scroll movements
  if (Math.abs(scrollAccumulator) < scrollThreshold) {
    return
  }

  const nextIndex = scrollAccumulator > 0
    ? Math.min(currentIndex + 1, images.length - 1)
    : Math.max(currentIndex - 1, 0)

  // Prevent switching at boundary
  if (nextIndex === currentIndex) {
    return
  }

  event.preventDefault()
  switchToNextImage(imageStack, images, currentIndex, nextIndex, isZoomed)

  lastSwitchTime = currentTime
  scrollAccumulator = 0
}

function handleWheelOnNormal(
  event: WheelEvent,
  imageStack: HTMLElement,
  images: HTMLImageElement[],
  currentIndex: number,
): void {
  // Prevent rapid wheel events
  if (isWheeling) {
    return
  }

  event.preventDefault()
  isWheeling = true

  const { spacing } = getCachedLayoutConfig()
  const delta = event.deltaY * scrollDamping

  stackScrollOffset += delta
  flashScrollingState(imageStack)

  // Prevent rapid calculation from applyImageOffsets
  requestAnimationFrame(() => {
    applyImageOffsets(images, currentIndex, spacing)
    isWheeling = false
  })
}

function handleWheel(event: WheelEvent): void {
  const stackDate = getStackDate()
  if (!stackDate) {
    return
  }

  const { imageStack, images, currentCenterIndex } = stackDate
  const isZoomed = images[currentCenterIndex].classList.contains('zoomed')

  // Zoomed: wheel to switch images
  if (isZoomed) {
    handleWheelOnZoomed(event, imageStack, images, currentCenterIndex, isZoomed)
    return
  }

  // Normal: wheel to scroll stack
  handleWheelOnNormal(event, imageStack, images, currentCenterIndex)
}

// Astro Events
document.addEventListener('astro:before-swap', cleanup)
document.addEventListener('astro:after-swap', () => setupStackLayout())

// Desktop Events
window.addEventListener('resize', handleResize)
document.addEventListener('keydown', handleKeyDown)
document.addEventListener('click', handleClick)
document.addEventListener('wheel', handleWheel, { passive: false })

setupStackLayout()
</script>
